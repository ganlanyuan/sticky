{"version":3,"sources":["sticky.native.js"],"names":["sticky","options","Core","this","stickyClassNames","className","isInRange","isWrapped","isSticking","isFixed","isAbsolute","stickyRectEdge","containerRectEdge","init","scope","gn","optimizedResize","add","onResize","window","addEventListener","ticking","jsWrapper","getBoundingClientRect","POSITION","CONTAINER","bottom","requestAnimationFrame","onScroll","extend","container","padding","position","breakpoints","BP","PADDING","WINDOWWIDTH","innerWidth","WINDOWHEIGHT","innerHeight","prototype","wrapSticky","parent","parentNode","indexOf","document","createElement","wrap","getFixedBreakpoint","getAbsoluteBreakpoint","stickyHeight","updateSizes","style","getComputedStyle","pattern","left","exec","marginLeft","parseInt","Length","toPx","right","marginRight","top","marginTop","marginBottom","stickyWidth","clientWidth","offsetHeight","isFixedBreakpoint","isAbsoluteBreakpoint","destory","width","unwrap","replace","checkRange","Array","isArray","length","height","ready","stickyEls","querySelectorAll","arr","Error","querySelector","i","push"],"mappings":"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","file":"sticky.native.js","sourcesContent":["/**\n  * sticky.native (works with go-native)\n  *\n  * v0.1.5\n  * @author William Lin\n  * @license The MIT License (MIT)\n  * https://github.com/ganlanyuan/sticky\n  */\n\nvar sticky = (function () {\n  'use strict';\n\n  return function (options) {\n    options = gn.extend({ \n      sticky: '.sticky',\n      container: false,\n      padding: 0,\n      position: 'top',\n      breakpoints: false,\n    }, options || {});\n\n    var BP = options.breakpoints,\n        CONTAINER,\n        PADDING = options.padding,\n        POSITION = options.position,\n        WINDOWWIDTH = window.innerWidth,\n        WINDOWHEIGHT = window.innerHeight;\n\n    function Core (sticky) {\n      this.sticky = sticky;\n      this.stickyClassNames = this.sticky.className;\n\n      this.isInRange = false;\n      this.isWrapped = false;\n      this.isSticking = false;\n      this.isFixed = false;\n      this.isAbsolute = false;\n      this.stickyRectEdge = 0;\n      this.containerRectEdge = false;\n\n      this.init(); \n\n      var scope = this;\n      gn.optimizedResize.add(function () { \n        scope.onResize(); \n      });\n\n      window.addEventListener('scroll', function () { \n        scope.ticking = false;\n        if (!scope.isWrapped) { return; }\n        scope.stickyRectEdge = scope.jsWrapper.getBoundingClientRect()[POSITION];\n        scope.containerRectEdge = (CONTAINER) ? CONTAINER.getBoundingClientRect().bottom : false;\n        if (!scope.ticking) {\n          window.requestAnimationFrame(function () {\n            if (scope.isWrapped) {\n              scope.onScroll(); \n            }\n            scope.ticking = false;\n          });\n        }\n        scope.ticking = true;\n      });\n    }\n\n    Core.prototype = {\n      // wrap sticky with a new <div>\n      // to track sticky width and BoundingClientRect\n      wrapSticky: function () {\n        var parent = this.sticky.parentNode;\n        if (parent.className.indexOf('sticky-container') !== -1) {\n          this.jsWrapper = parent;\n        } else {\n          this.jsWrapper = document.createElement('div');\n          this.jsWrapper.className = 'js-sticky-container';\n          gn.wrap(this.sticky, this.jsWrapper);\n        }\n\n        this.isWrapped = true;\n      },\n\n      // get pinned / fixed breakpoint\n      // based on sticky getBoundingClientRect().top/bottom\n      getFixedBreakpoint: function () {\n        if (POSITION === 'top') {\n          return PADDING;\n        } else {\n          return WINDOWHEIGHT - PADDING;\n        }\n      },\n\n      // get followed / absolute breakpoint\n      // based on container getBoundingClientRect().bottom\n      getAbsoluteBreakpoint: function () {\n        if (!CONTAINER) {\n          return false;\n        } else {\n          if (POSITION === 'top') {\n            return  this.stickyHeight + PADDING;\n          } else {\n            return WINDOWHEIGHT;\n          }\n        }\n      },\n\n      // update sizes:\n      // get sticky, container and window information to calculate\n      // two breakpoints: pinned to window / follow container\n      // \n      // do this on document load & window resize\n      updateSizes: function () {\n        var style = window.getComputedStyle(this.sticky),\n            pattern = /\\d/, // check if value contains digital number\n            left = (pattern.exec(style.marginLeft) === null) ? 0 : parseInt(Length.toPx(sticky, style.marginLeft)),\n            right = (pattern.exec(style.marginRight) === null) ? 0 : parseInt(Length.toPx(sticky, style.marginRight)),\n            top = (pattern.exec(style.marginTop) === null) ? 0 : parseInt(Length.toPx(sticky, style.marginTop)),\n            bottom = (pattern.exec(style.marginBottom) === null) ? 0 : parseInt(Length.toPx(sticky, style.marginBottom));\n\n        // update sizes, position and breakpoints\n        this.stickyWidth = this.jsWrapper.clientWidth - left - right;\n        this.stickyHeight = this.sticky.offsetHeight + top + bottom;\n\n        this.isFixedBreakpoint = this.getFixedBreakpoint();\n        this.isAbsoluteBreakpoint = this.getAbsoluteBreakpoint();\n      },\n\n      // destory:\n      // restore everything when window size is not in the range\n      // remove inserted <div>, classnames, styles and initialize ticking variables\n      destory: function () {\n        this.sticky.className = this.stickyClassNames;\n        this.sticky.style.width = '';\n        this.sticky.style[POSITION] = '';\n        gn.unwrap(this.jsWrapper);\n\n        if (this.isSticking) {\n          this.sticky.className = this.sticky.className.replace(' js-sticky', '');\n          this.sticky.style.position = '';\n          this.sticky.style.width = '';\n          this.sticky.style.top = '';\n          this.sticky.style.bottom = '';\n          this.isSticking = false;\n          this.isFixed = false;\n          this.isAbsolute = false;\n        }\n\n        this.isInRange = false;\n        this.isWrapped = false;\n        this.isSticking = false;\n        this.isFixed = false;\n        this.isAbsolute = false;\n      },\n\n      // check if the window size is in the range\n      checkRange: function () {\n        if (!BP) {\n          return true;\n        } else if (typeof BP === 'number') {\n          return WINDOWWIDTH >= BP;\n        } else if (Array.isArray(BP)) {\n          switch (BP.length) {\n            case 1:\n              return WINDOWWIDTH >= BP[0];\n            case 2:\n              return WINDOWWIDTH >= BP[0] && WINDOWWIDTH < BP[1];\n            case 3:\n              return WINDOWWIDTH >= BP[0] && WINDOWWIDTH < BP[1] || WINDOWWIDTH >= BP[2];\n            case 4:\n              return WINDOWWIDTH >= BP[0] && WINDOWWIDTH < BP[1] || WINDOWWIDTH >= BP[2] && WINDOWWIDTH < BP[3];\n          }\n        }\n      },\n\n      // init:\n      // check if the window is in the range\n      // if so, wrap sticky with new <div> and store size information\n      // otherwise，unwrap <div> and initialize variables\n      init: function () {\n        this.isInRange = this.checkRange();\n\n        if (this.isInRange && !this.isWrapped) {\n          this.wrapSticky();\n          this.updateSizes();\n        } else if (!this.isInRange && this.isWrapped) {\n          this.destory();\n        }\n\n        if (this.isWrapped) {\n          this.stickyRectEdge = this.jsWrapper.getBoundingClientRect()[POSITION];\n          this.containerRectEdge = (CONTAINER) ? CONTAINER.getBoundingClientRect().bottom : false;\n\n          this.onScroll();\n          if (this.isSticking) { this.sticky.style.width = this.stickyWidth + 'px'; }\n        }\n      },\n\n      // onresize:\n      // same things with init, but always need to check size information to update sticky status,\n      // and update sticky width while it's pinned or following\n      onResize: function () {\n        if (window.innerWidth !== WINDOWWIDTH) { WINDOWWIDTH = window.innerWidth; }\n        if (window.innerHeight !== WINDOWHEIGHT) { WINDOWHEIGHT = window.innerHeight; }\n\n        this.init();\n\n        if (this.isWrapped) {\n          this.updateSizes();\n        }\n      },\n\n      // onscroll:\n      // change sticky status based on sticky / container scrollTop\n      // the adventage of using getBoundingClientRect().top instead of offsetTop is scope the sticky will not be affected by other element's height changing while scrolling\n      // e.g. when window scroll down, the header become fixed positioned, thus height property become 0\n      onScroll: function () {\n        if (this.stickyRectEdge > this.isFixedBreakpoint) {\n          // normal - non-sticky\n          // reset position, top, bottom, width, height\n          if (this.isSticking) {\n            this.sticky.className = this.sticky.className.replace(' js-sticky', '');\n            this.jsWrapper.style.height = '';\n            this.sticky.style.position = '';\n            this.sticky.style.width = '';\n            this.sticky.style.top = '';\n            this.sticky.style.bottom = '';\n            this.isSticking = false;\n            this.isFixed = false;\n            this.isAbsolute = false;\n          }\n        } else {\n          // add .js-sticky, set width, height\n          if (!this.isSticking) {\n            this.sticky.className += ' js-sticky';\n            this.sticky.style.width = this.stickyWidth + 'px';\n            this.jsWrapper.style.height = this.stickyHeight + 'px';\n            this.isSticking = true;\n          }\n\n          if (CONTAINER) {\n            if (!this.isFixed && this.stickyRectEdge <= this.isFixedBreakpoint && this.containerRectEdge > this.isAbsoluteBreakpoint) {\n              // fixed (with container):\n              // remove container relative-position\n              CONTAINER.style.position = '';\n              this.sticky.style.position = 'fixed';\n              this.sticky.style[POSITION] = PADDING + 'px';\n              if (POSITION === 'top') {\n                this.sticky.style.bottom = '';\n              }\n              this.isFixed = true;\n              this.isAbsolute = false;\n            } else if (!this.isAbsolute && this.containerRectEdge <= this.isAbsoluteBreakpoint) {\n              // absolute:\n              CONTAINER.style.position = 'relative';\n              this.sticky.style.position = 'absolute';\n              if (POSITION === 'top') {\n                this.sticky.style.top = '';\n                this.sticky.style.bottom = '0px';\n              }\n              this.isFixed = false;\n              this.isAbsolute = true;\n            }\n          } else {\n            // fixed (without container)\n            if (!this.isFixed && this.stickyRectEdge <= this.isFixedBreakpoint) {\n              this.sticky.style.position = 'fixed';\n              this.sticky.style[POSITION] = PADDING + 'px';\n              this.isFixed = true;\n            }\n          }\n        }\n      },\n    };\n\n    gn.ready(function () {\n      // get sticky elements on dom ready\n      var stickyEls = document.querySelectorAll(options.sticky),\n          arr = [];\n      // if not sticky element been found, do nothing\n      if (stickyEls.length === 0) { \n        throw new Error('\"' + options.sticky + '\" doesn\\'t exist.');\n      }\n\n      // get CONTAINER on dom ready\n      CONTAINER = (options.container) ? document.querySelector(options.container) : false;\n\n      for (var i = stickyEls.length; i--;) {\n        arr.push(new Core(stickyEls[i]));\n      }\n\n      // return sticky Array\n      return arr;\n    });\n  };\n\n})();"],"sourceRoot":"/source/"}